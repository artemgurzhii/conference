'use strict';

(function (modules) {
var installedModules = {};

function __webpack_require__(moduleId) {

if (installedModules[moduleId])
return installedModules[moduleId].exports;

var module = installedModules[moduleId] = {
exports: {},
id: moduleId,
loaded: false
 };

modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);

module.loaded = true;

return module.exports;
	}

__webpack_require__.m = modules;

__webpack_require__.c = installedModules;

__webpack_require__.p = "";

return __webpack_require__(0);
})(
[
function (module, exports, __webpack_require__) {

	__webpack_require__(1);
	__webpack_require__(2);
	__webpack_require__(3);
	__webpack_require__(4);
	__webpack_require__(5);
	__webpack_require__(6);

},
function (module, exports) {

	{
		var geolocator = function () {

			'use strict';

			var onSuccess,
			    onError,
			    mCanvasId,
			    googleLoaderURL = 'https://www.google.com/jsapi',
			    mapsVersion = '3.18',
			    ipGeoSources = [{ url: '//freegeoip.net/json/', cbParam: 'callback' }, { url: '//www.geoplugin.net/json.gp', cbParam: 'jsoncallback' }, { url: '//geoiplookup.wikimedia.org/', cbParam: '' }],
			    defaultSourceIndex = 1,
			    sourceIndex;

			function loadScript(url, callback, removeOnCallback) {
				var script = document.createElement('script');
				script.async = true;

				function execCb(cb, data) {
					if (removeOnCallback && script.parentNode) {
						script.parentNode.removeChild(script);
					}
					if (typeof cb === 'function') {
						cb(data);
					}
				}

				if (script.readyState) {
					script.onreadystatechange = function (e) {
						if (script.readyState === 'loaded' || script.readyState === 'complete') {
							script.onreadystatechange = null;
							execCb(callback);
						}
					};
				} else {
					script.onload = function (e) {
						execCb(callback);
					};
				}

				script.onerror = function (e) {
					var errMsg = 'Could not load source at ' + String(url).replace(/\?.*$/, '');
					execCb(onError, new Error(errMsg));
				};

				script.src = url;
				document.getElementsByTagName('head')[0].appendChild(script);
			}

			function loadGoogleMaps(callback) {
				function loadMaps() {
					if (geolocator.__glcb) {
						delete geolocator.__glcb;
					}
					google.load('maps', mapsVersion, { other_params: '', callback: callback });
				}
				if (window.google !== undefined && google.maps !== undefined) {
					if (callback) {
						callback();
					}
				} else {
					if (window.google !== undefined && google.loader !== undefined) {
						loadMaps();
					} else {
						geolocator.__glcb = loadMaps;
						loadScript(googleLoaderURL + '?callback=geolocator.__glcb');
					}
				}
			}

			function drawMap(elemId, mapOptions, infoContent) {
				var map,
				    marker,
				    infowindow,
				    elem = document.getElementById(elemId);
				if (elem) {
					map = new google.maps.Map(elem, mapOptions);
					marker = new google.maps.Marker({
						position: mapOptions.center,
						map: map
					});
					infowindow = new google.maps.InfoWindow();
					infowindow.setContent(infoContent);
					google.maps.event.addListener(marker, 'click', function () {
						infowindow.open(map, marker);
					});
					geolocator.location.map = {
						canvas: elem,
						map: map,
						options: mapOptions,
						marker: marker,
						infoWindow: infowindow
					};
				} else {
					geolocator.location.map = null;
				}
			}

			function reverseGeoLookup(latlng, callback) {
				var geocoder = new google.maps.Geocoder();
				function onReverseGeo(results, status) {
					if (status === google.maps.GeocoderStatus.OK) {
						if (callback) {
							callback(results);
						}
					}
				}
				geocoder.geocode({ 'latLng': latlng }, onReverseGeo);
			}

			function fetchDetailsFromLookup(data) {
				if (data && data.length > 0) {
					var i,
					    c,
					    o = {},
					    comps = data[0].address_components;
					for (i = 0; i < comps.length; i += 1) {
						c = comps[i];
						if (c.types && c.types.length > 0) {
							o[c.types[0]] = c.long_name;
							o[c.types[0] + '_s'] = c.short_name;
						}
					}
					geolocator.location.formattedAddress = data[0].formatted_address;
					geolocator.location.address = {
						street: o.route || '',
						neighborhood: o.neighborhood || '',
						town: o.sublocality || '',
						city: o.locality || '',
						region: o.administrative_area_level_1 || '',
						country: o.country || '',
						countryCode: o.country_s || '',
						postalCode: o.postal_code || '',
						streetNumber: o.street_number || ''
					};
				}
			}

			function finalize(coords) {
				var latlng = new google.maps.LatLng(coords.latitude, coords.longitude);
				function onGeoLookup(data) {
					fetchDetailsFromLookup(data);
					var zoom = geolocator.location.ipGeoSource === null ? 14 : 7,
					    mapOptions = {
						zoom: zoom,
						center: latlng,
						mapTypeId: 'roadmap'
					};
					drawMap(mCanvasId, mapOptions, data[0].formatted_address);
					if (onSuccess) {
						onSuccess.call(null, geolocator.location);
					}
				}
				reverseGeoLookup(latlng, onGeoLookup);
			}

			function getPosition(fallbackToIP, html5Options) {
				geolocator.location = null;

				function fallback(error) {
					var ipsIndex = fallbackToIP === true ? 0 : typeof fallbackToIP === 'number' ? fallbackToIP : -1;
					if (ipsIndex >= 0) {
						geolocator.locateByIP(onSuccess, onError, ipsIndex, mCanvasId);
					} else {
						if (onError) {
							onError(error);
						}
					}
				}

				function geoSuccess(position) {
					geolocator.location = {
						ipGeoSource: null,
						coords: position.coords,
						timestamp: new Date().getTime()
					};
					finalize(geolocator.location.coords);
				}

				function geoError(error) {
					fallback(error);
				}

				if (navigator.geolocation) {
					navigator.geolocation.getCurrentPosition(geoSuccess, geoError, html5Options);
				} else {
					fallback(new Error('geolocation is not supported.'));
				}
			}

			function buildLocation(ipSourceIndex, data) {
				switch (ipSourceIndex) {
					case 0:
						geolocator.location = {
							coords: {
								latitude: data.latitude,
								longitude: data.longitude
							},
							address: {
								city: data.city,
								country: data.country_name,
								countryCode: data.country_code,
								region: data.region_name
							}
						};
						break;
					case 1:
						geolocator.location = {
							coords: {
								latitude: data.geoplugin_latitude,
								longitude: data.geoplugin_longitude
							},
							address: {
								city: data.geoplugin_city,
								country: data.geoplugin_countryName,
								countryCode: data.geoplugin_countryCode,
								region: data.geoplugin_regionName
							}
						};
						break;
					case 2:
						geolocator.location = {
							coords: {
								latitude: data.lat,
								longitude: data.lon
							},
							address: {
								city: data.city,
								country: '',
								countryCode: data.country,
								region: ''
							}
						};
						break;
				}
				if (geolocator.location) {
					geolocator.location.coords.accuracy = null;
					geolocator.location.coords.altitude = null;
					geolocator.location.coords.altitudeAccuracy = null;
					geolocator.location.coords.heading = null;
					geolocator.location.coords.speed = null;
					geolocator.location.timestamp = new Date().getTime();
					geolocator.location.ipGeoSource = ipGeoSources[ipSourceIndex];
					geolocator.location.ipGeoSource.data = data;
				}
			}

			function onGeoSourceCallback(data) {
				var initialized = false;
				geolocator.location = null;
				delete geolocator.__ipscb;

				function gLoadCallback() {
					if (sourceIndex === 2) {
						if (window.Geo !== undefined) {
							buildLocation(sourceIndex, window.Geo);
							delete window.Geo;
							initialized = true;
						}
					} else {
						if (data !== undefined && typeof data !== 'string') {
							buildLocation(sourceIndex, data);
							initialized = true;
						}
					}

					if (initialized === true) {
						finalize(geolocator.location.coords);
					} else {
						if (onError) {
							onError(new Error(data || 'Could not get location.'));
						}
					}
				}

				loadGoogleMaps(gLoadCallback);
			}

			function loadIpGeoSource(source) {
				if (source.cbParam === undefined || source.cbParam === null || source.cbParam === '') {
					loadScript(source.url, onGeoSourceCallback, true);
				} else {
					loadScript(source.url + '?' + source.cbParam + '=geolocator.__ipscb', undefined, true);
				}
			}

			return {

				location: null,

				locate: function locate(successCallback, errorCallback, fallbackToIP, html5Options, mapCanvasId) {
					onSuccess = successCallback;
					onError = errorCallback;
					mCanvasId = mapCanvasId;
					function gLoadCallback() {
						getPosition(fallbackToIP, html5Options);
					}
					loadGoogleMaps(gLoadCallback);
				},

				locateByIP: function locateByIP(successCallback, errorCallback, ipSourceIndex, mapCanvasId) {
					sourceIndex = typeof ipSourceIndex !== 'number' || ipSourceIndex < 0 || ipSourceIndex >= ipGeoSources.length ? defaultSourceIndex : ipSourceIndex;
					onSuccess = successCallback;
					onError = errorCallback;
					mCanvasId = mapCanvasId;
					geolocator.__ipscb = onGeoSourceCallback;
					loadIpGeoSource(ipGeoSources[sourceIndex]);
				},

				isPositionError: function isPositionError(error) {
					return Object.prototype.toString.call(error) === '[object PositionError]';
				}
			};
		}();
		{}
	}

},
function (module, exports, __webpack_require__) {

	var require;var require;(function e(t, n, r) {
		function s(o, u) {
			if (!n[o]) {
				if (!t[o]) {
					var a = typeof require === "function" && require;
					if (!u && a) {
						return require(o, !0);
					}
					if (i) {
						return i(o, !0);
					}
					throw new Error("Cannot find module '" + o + "'");
				}
				var f = n[o] = {
					exports: {}
				};
				t[o][0].call(f.exports, function (e) {
					var n = t[o][1][e];
					return s(n ? n : e);
				}, f, f.exports, e, t, n, r);
			}
			return n[o].exports;
		}
		var i = typeof require === "function" && require;
		for (var o = 0; o < r.length; o += 1) {
			s(r[o]);
		}
		return s;
	})({
		1: [function (require, module, exports) {
			'use strict';

			module.exports = {
				load: load
			};

			function load(location, callback) {
				var xhr = getXHR();
				xhr.open('GET', location, true);
				xhr.onreadystatechange = createStateChangeListener(xhr, callback);
				xhr.send();
			}

			function createStateChangeListener(xhr, callback) {
				return function () {
					if (xhr.readyState === 4 && xhr.status === 200) {
						try {
							callback(null, JSON.parse(xhr.responseText));
						} catch (err) {
							callback(err, null);
						}
					}
				};
			}

			function getXHR() {
				return window.XMLHttpRequest ? new XMLHttpRequest() : new ActiveXObject('Microsoft.XMLHTTP');
			}
		}, {}],
		2: [function (require, module, exports) {
			'use strict';

			module.exports = function OptionsValidator(params) {
				if (!validateParams(params)) {
					throw new Error('-- OptionsValidator: required options missing');
				}
				if (!(this instanceof OptionsValidator)) {
					return new OptionsValidator(params);
				}

				var requiredOptions = params.required;

				this.getRequiredOptions = function () {
					return requiredOptions;
				};

				this.validate = function (parameters) {
					var errors = [];
					requiredOptions.forEach(function (requiredOptionName) {
						if (parameters[requiredOptionName] === undefined) {
							errors.push(requiredOptionName);
						}
					});
					return errors;
				};

				function validateParams(params) {
					if (!params) {
						return false;
					}
					return params.required !== undefined && params.required instanceof Array;
				}
			};
		}, {}],
		3: [function (require, module, exports) {
			'use strict';

			module.exports = {
				put: put,
				clear: clear,
				get: get,
				search: search,
				setOptions: setOptions
			};

			var FuzzySearchStrategy = require('./SearchStrategies/FuzzySearchStrategy');
			var LiteralSearchStrategy = require('./SearchStrategies/LiteralSearchStrategy');

			var data = [];
			var opt = {};
			opt.fuzzy = false;
			opt.limit = 10;
			opt.searchStrategy = opt.fuzzy ? FuzzySearchStrategy : LiteralSearchStrategy;

			function put(data) {
				if (isObject(data)) {
					return addObject(data);
				}
				if (isArray(data)) {
					return addArray(data);
				}
				return undefined;
			}

			function clear() {
				data.length = 0;
				return data;
			}

			function get() {
				return data;
			}

			function isObject(obj) {
				return !!obj && Object.prototype.toString.call(obj) === '[object Object]';
			}

			function isArray(obj) {
				return !!obj && Object.prototype.toString.call(obj) === '[object Array]';
			}

			function addObject(_data) {
				data.push(_data);
				return data;
			}

			function addArray(_data) {
				var added = [];
				for (var i = 0; i < _data.length; i += 1) {
					if (isObject(_data[i])) {
						added.push(addObject(_data[i]));
					}
				}
				return added;
			}

			function search(crit) {
				if (!crit) {
					return [];
				}
				return findMatches(data, crit, opt.searchStrategy, opt);
			}

			function setOptions(_opt) {
				opt = _opt || {};

				opt.fuzzy = _opt.fuzzy || false;
				opt.limit = _opt.limit || 10;
				opt.searchStrategy = _opt.fuzzy ? FuzzySearchStrategy : LiteralSearchStrategy;
			}

			function findMatches(data, crit, strategy, opt) {
				var matches = [];
				for (var i = 0; i < data.length && matches.length < opt.limit; i += 1) {
					var match = findMatchesInObject(data[i], crit, strategy, opt);
					if (match) {
						matches.push(match);
					}
				}
				return matches;
			}

			function findMatchesInObject(obj, crit, strategy, opt) {
				for (var key in obj) {
					if (!isExcluded(obj[key], opt.exclude) && strategy.matches(obj[key], crit)) {
						return obj;
					}
				}
			}

			function isExcluded(term, excludedTerms) {
				var excluded = false;
				excludedTerms = excludedTerms || [];
				for (var i = 0; i < excludedTerms.length; i += 1) {
					var excludedTerm = excludedTerms[i];
					if (!excluded && new RegExp(term).test(excludedTerm)) {
						excluded = true;
					}
				}
				return excluded;
			}
		}, {
			"./SearchStrategies/FuzzySearchStrategy": 4,
			"./SearchStrategies/LiteralSearchStrategy": 5
		}],
		4: [function (require, module, exports) {
			'use strict';

			module.exports = new FuzzySearchStrategy();

			function FuzzySearchStrategy() {
				this.matches = function (string, crit) {
					if (typeof string !== 'string' || typeof crit !== 'string') {
						return false;
					}
					var fuzzy = crit.split("").reduce(function (a, b) {
						return a + '[^' + b + ']*' + b;
					});
					fuzzy = new RegExp(fuzzy, 'gi');
					return !!fuzzy.test(string);
				};
			}
		}, {}],
		5: [function (require, module, exports) {
			'use strict';

			module.exports = new LiteralSearchStrategy();

			function LiteralSearchStrategy() {
				this.matches = function (string, crit) {
					if (typeof string !== 'string') {
						return false;
					}
					string = string.trim();
					return string.toLowerCase().indexOf(crit.toLowerCase()) >= 0;
				};
			}
		}, {}],
		6: [function (require, module, exports) {
			'use strict';

			module.exports = {
				compile: compile,
				setOptions: setOptions
			};

			var options = {};
			options.pattern = /\{(.*?)\}/g;
			options.template = '';
			options.middleware = function () {};

			function setOptions(_options) {
				options.pattern = _options.pattern || options.pattern;
				options.template = _options.template || options.template;
				if (typeof _options.middleware === 'function') {
					options.middleware = _options.middleware;
				}
			}

			function compile(data) {
				return options.template.replace(options.pattern, function (match, prop) {
					var value = options.middleware(prop, data[prop], options.template);
					if (value !== undefined) {
						return value;
					}
					return data[prop] || match;
				});
			}
		}, {}],
		7: [function (require, module, exports) {
			(function (window, document, undefined) {
				'use strict';

				var options = {
					searchInput: null,
					resultsContainer: null,
					json: [],
					searchResultTemplate: '<li><a href="{url}" title="{desc}">{title}</a></li>',
					templateMiddleware: function templateMiddleware() {},
					noResultsText: 'No results found',
					limit: 10,
					fuzzy: false,
					exclude: []
				};

				var requiredOptions = ['searchInput', 'resultsContainer', 'json'];

				var templater = require('./Templater');
				var repository = require('./Repository');
				var jsonLoader = require('./JSONLoader');
				var optionsValidator = require('./OptionsValidator')({
					required: requiredOptions
				});
				var utils = require('./utils');

				window.SimpleJekyllSearch = function SimpleJekyllSearch(_options) {
					var errors = optionsValidator.validate(_options);
					if (errors.length > 0) {
						throwError('You must specify the following required options: ' + requiredOptions);
					}

					options = utils.merge(options, _options);

					templater.setOptions({
						template: options.searchResultTemplate,
						middleware: options.templateMiddleware
					});

					repository.setOptions({
						fuzzy: options.fuzzy,
						limit: options.limit
					});

					if (utils.isJSON(options.json)) {
						initWithJSON(options.json);
					} else {
						initWithURL(options.json);
					}
				};

				window.SimpleJekyllSearch.init = window.SimpleJekyllSearch;

				if (typeof window.SimpleJekyllSearchInit === 'function') {
					window.SimpleJekyllSearchInit.call(this, window.SimpleJekyllSearch);
				}

				function initWithJSON(json) {
					repository.put(json);
					registerInput();
				}

				function initWithURL(url) {
					jsonLoader.load(url, function (err, json) {
						if (err) {
							throwError('failed to get JSON (' + url + ')');
						}
						initWithJSON(json);
					});
				}

				function emptyResultsContainer() {
					options.resultsContainer.innerHTML = '';
				}

				function appendToResultsContainer(text) {
					options.resultsContainer.innerHTML += text;
				}

				function registerInput() {
					options.searchInput.addEventListener('keyup', function (e) {
						var key = e.which;
						var query = e.target.value;
						if (isWhitelistedKey(key) && isValidQuery(query)) {
							emptyResultsContainer();
							render(repository.search(query));
						}
					});
				}

				function render(results) {
					if (results.length === 0) {
						return appendToResultsContainer(options.noResultsText);
					}
					for (var i = 0; i < results.length; i += 1) {
						appendToResultsContainer(templater.compile(results[i]));
					}
				}

				function isValidQuery(query) {
					return query && query.length > 0;
				}

				function isWhitelistedKey(key) {
					return [13, 16, 20, 37, 38, 39, 40, 91].indexOf(key) === -1;
				}

				function throwError(message) {
					throw new Error('SimpleJekyllSearch --- ' + message);
				}
			})(window, document);
		}, {
			"./JSONLoader": 1,
			"./OptionsValidator": 2,
			"./Repository": 3,
			"./Templater": 6,
			"./utils": 8
		}],
		8: [function (require, module, exports) {
			'use strict';

			module.exports = {
				merge: merge,
				isJSON: isJSON
			};

			function merge(defaultParams, mergeParams) {
				var mergedOptions = {};
				for (var option in defaultParams) {
					if (defaultParams.hasOwnProperty(option)) {
						mergedOptions[option] = defaultParams[option];
						if (mergeParams[option] !== undefined) {
							mergedOptions[option] = mergeParams[option];
						}
					}
				}
				return mergedOptions;
			}

			function isJSON(json) {
				try {
					if (json instanceof Object && JSON.parse(JSON.stringify(json))) {
						return true;
					}
					return false;
				} catch (e) {
					return false;
				}
			}
		}, {}]
	}, {}, [7]);

},
function (module, exports) {

	SimpleJekyllSearch({
		searchInput: document.getElementsByClassName('search-input')[0],
		resultsContainer: document.getElementsByClassName('search-results-list')[0],
		searchResultTemplate: '<li><a href="{url}">{title} - {date}</a></li>',
		json: 'data/search.json',
		noResultsText: '<li>No results found</li>',
		limit: 10,
		fuzzy: true
	});

},
function (module, exports) {

	var searchWrap = document.querySelector('div.search-container'),
	    searchInput = searchWrap.querySelector('input.search-input'),
	    searchIcon = searchWrap.querySelector('i.clear-search-input'),
	    searchList = searchWrap.querySelector('ul.search-results-list');

	var deleteSearchList = function deleteSearchList() {
		while (searchList.firstChild) {
			searchList.removeChild(searchList.firstChild);
		}
		searchInput.value = '';
	};

	searchIcon.addEventListener('click', deleteSearchList, false);
	document.body.addEventListener('click', deleteSearchList, false);

},
function (module, exports) {

	function createNewElement() {
		var element = arguments.length <= 0 || arguments[0] === undefined ? 'DIV' : arguments[0];

		var newElement = document.createElement(element);
		document.body.appendChild(newElement);
		return newElement;
	}

},
function (module, exports) {

	var XHR = function XHR(method, url, asyncLoad, callback) {
		var request = new XMLHttpRequest();
		request.open(method, url, asyncLoad);
		request.send();
		request.onreadystatechange = function () {
			if (request.readyState === 4) {
				if (request.status === 200) {
					console.log(request.responseText);
				} else {
					console.log(request.status + ': ' + request.statusText);
				}
			} else {
				return;
			}
		};
	};
	var a = XHR('GET', 'http://localhost:3000/data/search.json', true);
	console.log(a);

}
]);